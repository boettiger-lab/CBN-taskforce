import streamlit as st
import altair as alt
import ibis
from ibis import _
import pandas as pd 
import traceback
import openai
from variables import *
from utils import *
import traceback
import importlib

def main():
    con = ibis.duckdb.connect("duck.db", extensions=["spatial"])
    current_tables = con.list_tables()
    
    if "mydata" not in set(current_tables):
        tbl = con.read_parquet(ca_parquet)
        con.create_table("mydata", tbl)

    ca = con.table("mydata")

    st.set_page_config(layout="wide", page_title="CA Protected Areas Explorer", page_icon=":globe:")
    # session state for syncing app 
    for key in keys:
        if key not in st.session_state:
            st.session_state[key] = False
    
    for col,val in style_options.items():
        for name in val['stops']:
            key = val['property']+str(name[0])
            if key not in st.session_state:
                st.session_state[key] = True
    
                
    #customizing style with CSS 
    st.markdown(app_formatting,unsafe_allow_html=True)
    
    st.markdown("<h2>CA 30x30 Planning & Assessment Prototype</h2>", unsafe_allow_html=True)
    
    st.markdown('<p class="medium-font"> In October 2020, Governor Newsom issued <a href="https://www.gov.ca.gov/wp-content/uploads/2020/10/10.07.2020-EO-N-82-20-.pdf" target="_blank">Executive Order N-82-20</a>, which establishes a state goal of conserving 30% of California‚Äôs lands and coastal waters by 2030 ‚Äì known as <a href="https://www.californianature.ca.gov/" target="_blank">CA 30x30</a>. </p>',
    unsafe_allow_html=True)
    
    st.markdown('<p class = "medium-font"> With this tool, you can explore habitats and features that support biodiversity within California‚Äôs 30x30 conservation areas, other conservation areas, and non-conserved lands. This tool can provide insight into what we have conserved, what is lacking protection, and opportunities to fill these gaps. </p>', unsafe_allow_html = True)
    
    st.divider()
    
    #############
    
    chatbot_container = st.container()
    with chatbot_container:
        llm_left_col, llm_right_col = st.columns([4,1], vertical_alignment = "bottom")
        with llm_left_col:
            with st.popover("üí¨ Example Queries"):
                st.markdown(example_queries)
                st.warning(chatbot_limitations, icon="‚ö†Ô∏è")
                st.info(chatbot_info, icon="‚ÑπÔ∏è")
        with llm_right_col:
            llm_choice = st.selectbox("Select LLM:", llm_options, key = "llm", help = "Select which model to use.")   
            llm = llm_options[llm_choice]
    
    
    ##### Chatbot stuff 
    from pydantic import BaseModel, Field
    class SQLResponse(BaseModel):
        """Defines the structure for SQL response."""
        sql_query: str = Field(description="The SQL query generated by the assistant.")
        explanation: str = Field(description="A detailed explanation of how the SQL query answers the input question.")
    
    with open('app/system_prompt.txt', 'r') as file:
        template = file.read()
    
    from langchain_openai import ChatOpenAI
    managers = ca.sql("SELECT DISTINCT manager FROM mydata;").execute()
    names = ca.sql("SELECT name FROM mydata GROUP BY name HAVING SUM(acres) >10000;").execute()
    ecoregions = ca.sql("SELECT DISTINCT ecoregion FROM mydata;").execute()
    
    from langchain_core.prompts import ChatPromptTemplate
    prompt = ChatPromptTemplate.from_messages([
        ("system", template),
        ("human", "{input}")
    ]).partial(dialect="duckdb", table_info = ca.schema(), managers = managers, names = names, ecoregions = ecoregions)
    
    chatbot_toggles = {key: False for key in keys}
    structured_llm = llm.with_structured_output(SQLResponse)
    few_shot_structured_llm = prompt | structured_llm
    
    @st.cache_data(show_spinner = 'Invoking query...')
    def run_sql(query):
        """
        Filter data based on an LLM-generated SQL query and return matching IDs.
        Args: query (str): The natural language query to filter the data.
        """
        output = few_shot_structured_llm.invoke(query)
        sql_query = output.sql_query
        explanation =output.explanation
        if not sql_query: # if the chatbot can't generate a SQL query.
            return pd.DataFrame({'id' : []}),'', explanation
        result = ca.sql(sql_query).execute()
        if result.empty:
            explanation = "This query did not return any results. Please try again with a different query."
            if 'geom' in result.columns:
                return result.drop('geom',axis = 1), sql_query, explanation 
            else: 
                return result, sql_query, explanation 
        return result, sql_query, explanation
    
    filters = {}
    
    ##### Chatbot 
    with chatbot_container:
        with llm_left_col:
            example_query = "üëã Input query here"
            prompt = st.chat_input(example_query, key="chain", max_chars=300)
    
    with chatbot_container:
        _,log_query_col, _ = st.columns([.001, 5,1], vertical_alignment = "top")
        with log_query_col:
            log_queries = st.checkbox("Save query", value = True, help = "Saving your queries helps improve this tool and guide conservation efforts. Your data is stored in a private location. For more details, see 'Why save your queries?' at the bottom of this page.")
            
    if prompt:
        try:
            llm_output, sql_query, llm_explanation = run_sql(prompt)
            if ("id" in llm_output.columns) and (not llm_output.empty):
                llm_cols = extract_columns(sql_query)
                for x in llm_cols:
                    group_by_name, group_by = next(((k, v) for k, v in select_column.items() if v == x), (None, None))
                    if group_by and st.session_state.get("color") != group_by_name:
                        st.session_state["color"] = group_by_name
                        st.experimental_rerun()
        except Exception:
            pass  # errors handled in main block later
    
    with st.container():
        if prompt: 
            st.chat_message("user").write(prompt)
            try:
                with st.chat_message("assistant"):
                    with st.spinner("Invoking query..."):
                        llm_output, sql_query, llm_explanation = run_sql(prompt)
                        minio_logger(log_queries, prompt, sql_query, llm_explanation, llm_choice, 'query_log.csv', "shared-ca30x30-app")
                        
                        # no sql query generated by chatbot
                        if sql_query == '':
                            st.success(llm_explanation)
                            not_mapping = True
                        else:    
                            # sql query generated but no results returned
                            if llm_output.empty:
                                st.warning(llm_explanation, icon="‚ö†Ô∏è")
                                st.caption("SQL Query:")
                                st.code(sql_query, language="sql")
                                st.stop()
                                
                            # output without mapping columns (id, geom)
                            elif "id" not in llm_output.columns and "geom" not in llm_output.columns:
                                st.write(llm_output)
                                not_mapping = True
        
                            # print results 
                            with st.popover("Explanation"):
                                st.write(llm_explanation)
                                if sql_query != '':
                                    st.caption("SQL Query:")
                                    st.code(sql_query,language = "sql") 
                                    
                        # extract ids, columns, bounds if present
                        if "id" in llm_output.columns and not llm_output.empty:
                            ids = llm_output['id'].tolist()
                            llm_cols = extract_columns(sql_query)
                            bounds = llm_output.total_bounds.tolist()
                        else:
                            ids, llm_cols = [], []
                            not_mapping = True
    
                        # update toggles based on returned columns from SQL query
                        llm_cols = [x.replace('mean_','pct_top_') for x in llm_cols]
                        chatbot_toggles = {
                            key: (True if key in llm_cols else value) 
                            for key, value in chatbot_toggles.items()
                        }
                        
                        # determine column and color_choice based on returned columns
                        for x in llm_cols:
                            group_by_name, group_by = next(((k, v) for k, v in select_column.items() if v == x), (None, None))
                            if group_by:
                                column = group_by
                                color_choice = group_by_name
                                colors = color_table(select_colors, color_choice, column)
                       
                        # apply toggles to session state
                        for key, value in chatbot_toggles.items():
                            st.session_state[key] = value
    
            except Exception as e:
                tb_str = traceback.format_exc()  # full multiline traceback string
                if isinstance(e, openai.BadRequestError):
                    st.error(error_messages["bad_request"](llm_choice, e, tb_str), icon="üö®")
                    
                elif isinstance(e, openai.RateLimitError):
                    st.error(error_messages["bad_request"](llm_choice, e, tb_str), icon="üö®")
                
                elif isinstance(e, openai.InternalServerError):
                    st.error(error_messages["internal_server_error"](llm_choice, e, tb_str), icon="üö®")
                
                elif isinstance(e, openai.NotFoundError):
                    st.error(error_messages["internal_server_error"](llm_choice, e, tb_str), icon="üö®")
                else:
                    prompt = prompt.replace('\n', '')
                    st.error(error_messages["unexpected_llm_error"](prompt, e, tb_str))
                st.stop()
    
    
    # Sidebar widgets
    with st.sidebar:
        with st.popover("‚ÑπÔ∏è Help"):
            st.markdown(help_message)
        if st.button("üßπ Clear Filters", type="secondary", help = 'Reset all the filters to their default state.'):
            st.rerun()
        st.divider()
        
        color_choice = st.radio(
            "Group by:",
            style_options,
            key="color",
            help="Select a category to change map colors and chart groupings.",
            captions=['','Degree of biodiversity protection [(what is this?)](https://www.protectedlands.net/uses-of-pad-us/#conservation-of-biodiversity-2)','', '', '', '', '', '', '']
        )
        colorby_vals = get_color_vals(style_options, color_choice)
        st.divider()

        #### Data layers
        st.markdown('<p class = "medium-font-sidebar"> Filters:</p>', help = "Apply filters to adjust what data is shown on the map. Filters do not modify the chatbot's input/output.", unsafe_allow_html= True)
        for label in style_options: # get selected filters (based on the buttons selected)
            with st.expander(label):  
                if label in ["GAP Code","30x30 Status"]: # gap code 1 and 2 are on by default
                    opts = get_buttons(style_options, label)
                else: # other buttons are not on by default.
                    opts = get_buttons(style_options, label) 
                filters.update(opts)
                
            selected = {k: v for k, v in filters.items() if v}
            if selected: 
                filter_cols = list(selected.keys())
                filter_vals = list(selected.values())
            else: 
                filter_cols = []
                filter_vals = []

        # county choice
        county_choice = st.selectbox("County", counties, index = None, placeholder='Counties', label_visibility = 'collapsed', key ='county')
        if county_choice != None:
            county_choice = county_choice.replace(' County','')
            filter_cols.append('county')
            filter_vals.append([county_choice])

        st.divider()


    #### Data layers 
        st.markdown('<p class = "medium-font-sidebar"> Data Layers:</p>', help = "Select data layers to display summary charts.", unsafe_allow_html= True)
        #display toggles to turn on data layers            
        for section, slider_key, items in layer_config:
            with st.expander(section):
                for item in items:
                    if len(item) == 5:
                        _, label, toggle_key, default, citation = item
                        st.toggle(label, key=toggle_key, value=default, help = citation)
                    else:
                        _, label, toggle_key, citation = item
                        st.toggle(label, key=toggle_key)
        st.divider() 
        st.markdown('<p class = "medium-font-sidebar"> Map Settings:</p>', help = "Select the mapping backend and basemap used to render the map. Use low resolution if experiencing performance issues.", unsafe_allow_html= True)
        # pmtiles selectino
        low_res = st.toggle("Low Resolution", key = 'pmtiles_choice', help = "Toggle on low resolution map if the app is lagging.")
        if low_res:
            pmtiles_file = low_res_pmtiles
        else:
            pmtiles_file = ca_pmtiles

        #leafmap options 
        leafmap_choice = st.selectbox("Leafmap module", ['MapLibre','Folium'])
        if leafmap_choice == "MapLibre":
            leafmap = importlib.import_module("leafmap.maplibregl")
            controls={'navigation': 'top-left', 
                      'fullscreen': 'top-left'}
            m = leafmap.Map(style="positron", zoom=5, controls = controls,
                           attribution_control=False)
        else:
            leafmap = importlib.import_module("leafmap.foliumap")
            m = leafmap.Map(center=[35, -100], zoom=5, 
                            scale_control = False, draw_control = False, search_control = False,
                            measure_control = False, layers_control = False)

        #basemap choices
        basemaps = leafmap.basemaps.keys()
        b = st.selectbox("Basemap", basemaps,index= 40)
        m.add_basemap(b, attribution = "")

        st.divider()

        # adding github logo 
        st.markdown(f"<div class='spacer'>{github_html}</div>", unsafe_allow_html=True)
        st.markdown(":left_speech_bubble: [Get in touch or report an issue](https://github.com/boettiger-lab/CBN-taskforce/issues)")
        if st.button("ü§ñ Clear Chatbot Cache", on_click=run_sql.clear, help = 'Reset the chatbot‚Äôs cache (useful if it behaves unexpectedly)'):
            run_sql.clear()
    
    column = select_column[color_choice]
    colors = color_table(select_colors, color_choice, column)
    main = st.container()
    with main:
        map_col, stats_col = st.columns([3,2])
    
    ## parameters for mapping the data (if we didn't use llm)
    if 'llm_output' not in locals():
        df_network, _, df_tab, df_bar_30x30 = get_summary_table(ca, column, select_colors, color_choice, filter_cols, filter_vals,colorby_vals)
        style = get_pmtiles_style(style_options[color_choice],pmtiles_file, low_res, filter_cols, filter_vals)
            
    else:
        if 'not_mapping' not in locals():
            style = get_pmtiles_style(style_options[color_choice], pmtiles_file, low_res, ids = ids)
        df_network, _ = get_summary_table_sql(ca, column, colors, ids)
    
    ## mapping data 
    legend, position, bg_color, fontsize = get_legend(style_options, color_choice, leafmap_choice, df_network, column)

    if 'not_mapping' not in locals():      
        if 'llm_output' not in locals():
            if county_choice != None:
                bounds = get_county_bounds(county_choice)
            else:
                bounds = [-124.42174575, 32.53428607, -114.13077782, 42.00950367]
        
        ### mapping with maplibre
        if leafmap_choice == "MapLibre":
       
            m.add_pmtiles(pmtiles_file, style=style, name="30x30 Conserved Areas (Terrestrial)", 
                          attribution = "CA Nature (2024)", tooltip=True, template = tooltip_template, fit_bounds=True)
            m.fit_bounds(bounds)
            m.add_legend(legend_dict = legend, fontsize = fontsize, bg_color = bg_color, position = position,
                        title = '')
        ### mapping with folium
        else: 
            m.add_pmtiles(pmtiles_file, style=style, name="30x30 Conserved Areas (Terrestrial) by CA Nature (2024)",
                          tooltip=False, zoom_to_layer=True)
            m.zoom_to_bounds(bounds)   
            
            # add custom tooltip to pmtiles layer
            for layer in m._children.values():
                if isinstance(layer, leafmap.PMTilesLayer):
                    pmtiles_layer = layer
                    break
            pmtiles_layer.add_child(CustomTooltip())
            m.add_legend(legend_dict = legend, position = position, draggable = False, title = '')

    # check if any layer toggle is active
    any_chart_toggled = any(
        st.session_state.get(toggle_key, False)
        for _, _, items in layer_config
        for _, _, toggle_key, *_ in items
    )
    
    # check if using stacked bar chart 
    show_stacked = (column not in ["status", "gap_code"]) and ('df_bar_30x30' in locals())
    
    if 'llm_output' in locals():
        show_chatbot_chart = any(item in llm_cols for item in keys)
    else:
        show_chatbot_chart = False
        
    # main display 
    with main:
        map_col, stats_col = st.columns([3,2])
        with map_col:
            if 'not_mapping' not in locals():   
                if leafmap_choice == "MapLibre":
                    m.to_streamlit(height=650) # adding map
                else: 
                    m.to_streamlit(height=650, add_layer_control = False) # adding map
                
                
            with st.expander("üîç View/download data"): # adding data table  
                if 'llm_output' not in locals():
                    st.dataframe(df_tab, use_container_width = True)  
                else:
                    if ('geom' in llm_output.columns) and (not llm_output.empty):
                        llm_output = llm_output.drop('geom',axis = 1)
                    if not llm_output.empty:
                        if 'name' in llm_output.columns and 'id' in llm_output.columns:
                            llm_grouped = (llm_output.groupby('name')
                                            .agg({col: ('sum' if col == 'acres' else 'first') 
                                              for col in llm_output.columns 
                                              if col != 'name'})).reset_index()
                            llm_grouped.drop(['id'], axis=1, inplace = True)
                            st.dataframe(llm_grouped, use_container_width = True)
                        else:
                            st.dataframe(llm_output, use_container_width = True)

            st.caption("***The label 'established' is inferred from the California Protected Areas Database, which may introduce artifacts. For details on our methodology, please refer to our <a href='https://github.com/boettiger-lab/CBN-taskforce' target='_blank'>our source code</a>.", unsafe_allow_html=True)
            st.caption("***Under California‚Äôs 30x30 framework, only GAP codes 1 and 2 are counted toward the conservation goal.") 
    
        with stats_col:
            with st.container():
                if 'not_mapping' not in locals():        
                    st.markdown('')
                    if column in ['status','gap_code']:
                        st.altair_chart(area_chart(df_network, column, color_choice), use_container_width=True)
    
                # display the pill selection if we will use any barcharts
                if any_chart_toggled or show_stacked or show_chatbot_chart or (column not in ['status','gap_code']):
                    option_map = {'acres': "Acres", 'percent_network': "Composition", 'percent_feature': "Representation",}

                    chart_choice = st.pills(
                        label="Bar chart metrics",
                        options=option_map.keys(),
                        format_func=lambda option: option_map[option],
                        selection_mode="single",
                        label_visibility="collapsed",
                        default="acres",
                    )
                    if chart_choice == "percent_network":
                        if column not in ['status','gap_code']:
                            st.altair_chart(area_chart(df_network, column, color_choice), use_container_width=True)
                    
                if (any_chart_toggled or show_stacked or show_chatbot_chart) and not chart_choice:
                    st.warning("Please select a metric to display bar chart.")
    
                if show_stacked:
                    if chart_choice in ["percent_feature","acres"]:
                        y_axis = 'percent_group' if (chart_choice == 'percent_feature') else 'acres'
                        chart_title = f"{color_choice}\n by 30x30 Status"
                        chart = stacked_bar(
                            df=df_bar_30x30,
                            x=column,
                            y=y_axis,
                            metric=chart_choice,
                            title=chart_title,
                            colors=colors,
                        )
                        st.altair_chart(chart, use_container_width=True) 
                        caption_text = (
                            f"*Percent of {color_choice} within each 30x30 conservation status."
                            if (chart_choice in ['percent_network','percent_feature'])
                            else f"*Acres of {color_choice} within each 30x30 conservation status."
                        )
                        st.markdown(f'<p class="caption">{caption_text}</p>', unsafe_allow_html=True)
                
                
                # Show data layer summary charts for toggled layers
                for _, _, items in layer_config:
                    for suffix, label, toggle_key, *_ in items:
                        if not st.session_state.get(toggle_key, False):
                            continue
            
                        suffix_clean = suffix.replace("pct_", "").replace("-", "_")
            
                        # Modify label with clearer formatting
                        if ('Richness' in label) and ('Endemic' not in label) and ('Rare' not in label):
                            label = f"Top {label}"
                        if ("Richness" in label) or ("Land" in label) or ("Communities" in label):
                            label += "\n"
    
                        if chart_choice == 'percent_network':
                            # Percent of NETWORK
                            feature_col_net = f"pct_network_{suffix_clean}"
                            st.altair_chart(
                                bar_chart(df_network, column, feature_col_net, label, metric=chart_choice, percent_type="Network"),
                                use_container_width=True,
                            )
    
                        elif chart_choice == 'percent_feature':
                            # Percent of FEATURE
                            feature_col_feat = f"pct_feature_{suffix_clean}"
                            _, df_feature, _, _ = get_summary_table(
                                ca,
                                column,
                                select_colors,
                                color_choice,
                                filter_cols,
                                filter_vals,
                                colorby_vals,
                                feature_col_feat,
                            )
    
                            st.altair_chart(
                                bar_chart(df_feature, column, feature_col_feat, label, metric=chart_choice, percent_type="Feature"),
                                use_container_width=True,
                            )
                        else:
                            feature_col = f"acres_{suffix_clean}"
                            st.altair_chart(
                                bar_chart(df_network, column, feature_col, label, metric=chart_choice),
                                use_container_width=True,
                            )

    st.divider()
    with open('app/footer.md', 'r') as file:
        footer = file.read()
    st.markdown(footer)

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        tb_str = traceback.format_exc()  # full multiline traceback string
        st.error(error_messages["unexpected_error"](e, tb_str))
