import streamlit as st
import streamlit.components.v1 as components
import base64
import leafmap.foliumap as leafmap
import altair as alt
import ibis
from ibis import _
import ibis.selectors as s
import os
import pandas as pd 
from shapely import wkb  
import sqlalchemy
import pathlib
from typing import Optional
from functools import reduce

from variables import *
from utils import *

## Create the table from remote parquet only if it doesn't already exist on disk
con = ibis.duckdb.connect("duck.db", extensions=["spatial"])
current_tables = con.list_tables()

if "mydata" not in set(current_tables):
    tbl = con.read_parquet(ca_parquet)
    con.create_table("mydata", tbl)

ca = con.table("mydata")

st.set_page_config(layout="wide", page_title="CA Protected Areas Explorer", page_icon=":globe:")
# session state for syncing app 
for key in keys:
    if key not in st.session_state:
        st.session_state[key] = False

for col,val in style_options.items():
    for name in val['stops']:
        key = val['property']+str(name[0])
        if key not in st.session_state:
            # st.session_state[key] = True
            st.session_state[key] = default_boxes.get(name[0], True)

            
#customizing style with CSS 
st.markdown(app_formatting,unsafe_allow_html=True)

st.markdown("<h2>CA 30x30 Planning & Assessment Prototype</h2>", unsafe_allow_html=True)

st.markdown('<p class="medium-font"> In October 2020, Governor Newsom issued <a href="https://www.gov.ca.gov/wp-content/uploads/2020/10/10.07.2020-EO-N-82-20-.pdf" target="_blank">Executive Order N-82-20</a>, which establishes a state goal of conserving 30% of California‚Äôs lands and coastal waters by 2030 ‚Äì known as <a href="https://www.californianature.ca.gov/" target="_blank">CA 30x30</a>. </p>',
unsafe_allow_html=True)

st.markdown('<p class = "medium-font"> With this tool, you can explore habitats and features that support biodiversity within California‚Äôs 30x30 conservation areas, other conservation areas, and non-conserved lands. This tool can provide insight into what we have conserved, what is lacking protection, and opportunities to fill these gaps. </p>', unsafe_allow_html = True)

st.divider()

# m = leafmap.Map(style="positron")
m = leafmap.Map(center=[35, -100], zoom=5, layers_control=True, fullscreen_control=True)

basemaps = leafmap.basemaps.keys()
#############

chatbot_container = st.container()
with chatbot_container:
    llm_left_col, llm_right_col = st.columns([5,1], vertical_alignment = "bottom")
    with llm_left_col:
        with st.popover("üí¨ Example Queries"):
            '''
            Mapping queries: 
            - Show me protected areas with any recent additions.
            - Show me amphibian biodiversity hotspots that aren't currently conserved.
            - Show me protected areas in disadvantaged communities.
            - Show me non-conserved areas where at least 80% of the land overlaps with regions of high endemic species richness.
            - Show me all 30x30 conserved lands managed by The Nature Conservancy.
            '''
            
            '''
            Exploratory data queries:
            - Which habitat types are underrepresented across 30x30 conserved lands?
            - What is a GAP code?
            - What percentage of 30x30 conserved land has been impacted by wildfire?
            - How many acres are newly protected easements?
            - List 10 counties with the highest fractions of protected areas.
            '''
            
            st.info('If the map appears blank, queried data may be too small to see at the default zoom level. Check the table below the map, as query results will also be displayed there.', icon="‚ÑπÔ∏è")
    
    with llm_right_col:
        llm_choice = st.selectbox("Select LLM:", llm_options, key = "llm", help = "Select which model to use.")   
        llm = llm_options[llm_choice]
           
##### Chatbot stuff 
from pydantic import BaseModel, Field
class SQLResponse(BaseModel):
    """Defines the structure for SQL response."""
    sql_query: str = Field(description="The SQL query generated by the assistant.")
    explanation: str = Field(description="A detailed explanation of how the SQL query answers the input question.")

with open('app/system_prompt.txt', 'r') as file:
    template = file.read()

from langchain_openai import ChatOpenAI
managers = ca.sql("SELECT DISTINCT manager FROM mydata;").execute()
names = ca.sql("SELECT name FROM mydata GROUP BY name HAVING SUM(acres) >10000;").execute()
ecoregions = ca.sql("SELECT DISTINCT ecoregion FROM mydata;").execute()

from langchain_core.prompts import ChatPromptTemplate
prompt = ChatPromptTemplate.from_messages([
    ("system", template),
    ("human", "{input}")
]).partial(dialect="duckdb", table_info = ca.schema(), managers = managers, names = names, ecoregions = ecoregions)

chatbot_toggles = {key: False for key in keys}
structured_llm = llm.with_structured_output(SQLResponse)
few_shot_structured_llm = prompt | structured_llm

@st.cache_data
def run_sql(query):
    """
    Filter data based on an LLM-generated SQL query and return matching IDs.

    Args:
        query (str): The natural language query to filter the data.
    """
    output = few_shot_structured_llm.invoke(query)
    sql_query = output.sql_query
    explanation =output.explanation
    if not sql_query: # if the chatbot can't generate a SQL query.
        st.success(explanation)
        return pd.DataFrame({'id' : []}),''
    result = ca.sql(sql_query).execute()
    if result.empty:
        explanation = "This query did not return any results. Please try again with a different query."
        st.warning(explanation, icon="‚ö†Ô∏è")
        st.caption("SQL Query:")
        st.code(sql_query,language = "sql") 
        if 'geom' in result.columns:
            return result.drop('geom',axis = 1), sql_query
        else: 
            return result, sql_query
    elif ("id" and "geom" not in result.columns): 
        st.write(result)  # if we aren't mapping, just print out the data  

    with st.popover("Explanation"):
        st.write(explanation)
        st.caption("SQL Query:")
        st.code(sql_query,language = "sql") 
    return result, sql_query

#############

filters = {}

with st.sidebar:
    with st.popover("‚ÑπÔ∏è Help"):
        '''
        - ‚ùå Safari/iOS not yet supported. Firefox recommended. 
        - üìä Use this sidebar to color-code the map by different attributes **(Group by)**, toggle on data layers and view summary charts **(Data Layers)**, or filter data **(Filters)**.
        - üí¨ For a more tailored experience, query our dataset of protected areas and their precomputed mean values for each of the displayed layers, using the experimental chatbot. The language model tries to answer natural language questions by drawing only from curated datasets (listed below).
        '''
    if st.button("üßπ Clear Filters", type="secondary", help = 'Reset all the filters to their default state.'):
        st.rerun()
    st.divider()


##### Chatbot 
with chatbot_container:
    with llm_left_col:
        example_query = "üëã Input query here"
        prompt = st.chat_input(example_query, key="chain", max_chars=300)

# Try to update the st.radio session state before the widget is rendered --
if prompt:
    try:
        llm_output, sql_query = run_sql(prompt)
        if ("id" in llm_output.columns) and (not llm_output.empty):
            cols = extract_columns(sql_query)
            for x in cols:
                group_by_name, group_by = next(((k, v) for k, v in select_column.items() if v == x), (None, None))
                if group_by and st.session_state.get("color") != group_by_name:
                    st.session_state["color"] = group_by_name
                    st.experimental_rerun()
    except Exception:
        pass  # errors handled in main block later

with st.container():
    if prompt: 
        st.chat_message("user").write(prompt)
        try:
            with st.chat_message("assistant"):
                with st.spinner("Invoking query..."):
                    llm_output, sql_query = run_sql(prompt)
                    if ("id" in llm_output.columns) and (not llm_output.empty):
                        ids = llm_output['id'].tolist()
                        cols = extract_columns(sql_query)
                        bounds = llm_output.total_bounds.tolist()
                        chatbot_toggles = {
                            key: (True if key in cols else value) 
                            for key, value in chatbot_toggles.items()
                        }
                        for x in cols:
                            group_by_name, group_by = next(((k, v) for k, v in select_column.items() if v == x), (None, None))
                            if group_by:
                                column = group_by
                                color_choice = group_by_name
                                colors = color_table(select_colors, color_choice, column)
                        for key, value in chatbot_toggles.items():
                            st.session_state[key] = value
                    else:
                        ids = []
        except Exception as e:
            import traceback
            import openai
        
            if isinstance(e, openai.BadRequestError):
                st.warning(
                    "ERROR: The LLM you selected is not working (400 error). Please select a different model.",
                    icon="‚ö†Ô∏è"
                )
                st.stop()
            elif isinstance(e, openai.InternalServerError):
                st.warning(
                    "ERROR: The LLM you selected is temporarily down (500 error). Please select a different model or try again later.",
                    icon="‚ö†Ô∏è"
                )

            elif isinstance(e, ValueError):
                st.error(f"{type(e).__name__}: {e}")
                st.warning(
                    "BUG: There's a problem in the application code. "
                    "Please help us fix it by reporting this issue on our GitHub:\n\n"
                    "[üìÑ Report on GitHub](https://github.com/boettiger-lab/CBN-taskforce/issues)",

                    icon="üêû"
                )



            else:
                error_message = f"ERROR: An unexpected error has occured with the following query:\n\n*{prompt}*\n\n which raised the following error:\n\n{type(e)}: {e}\n"
                st.warning("Please try again with a different query", icon="‚ö†Ô∏è")
                st.write(error_message)
            st.stop()

            


# Sidebar widgets
with st.sidebar: 
    color_choice = st.radio(
        "Group by:",
        style_options,
        key="color",
        help="Select a category to change map colors and chart groupings.",
        captions=['','Degree of biodiversity protection [(what is this?)](https://www.protectedlands.net/uses-of-pad-us/#conservation-of-biodiversity-2)','', '', '', '', '', '', '']
    )
    colorby_vals = get_color_vals(style_options, color_choice)
    alpha = 0.8
    st.divider()


    st.markdown('<p class = "medium-font-sidebar"> Filters:</p>', help = "Apply filters to adjust what data is shown on the map.", unsafe_allow_html= True)


    for label in style_options: # get selected filters (based on the buttons selected)
        with st.expander(label):  
            if label in ["GAP Code","30x30 Status"]: # gap code 1 and 2 are on by default
                opts = get_buttons(style_options, label, default_boxes)
            else: # other buttons are not on by default.
                opts = get_buttons(style_options, label) 
            filters.update(opts)
            
        selected = {k: v for k, v in filters.items() if v}
        if selected: 
            filter_cols = list(selected.keys())
            filter_vals = list(selected.values())
        else: 
            filter_cols = []
            filter_vals = []

    st.divider()

#### Data layers 
    st.markdown('<p class = "medium-font-sidebar"> Data Layers:</p>', help = "Select data layers to visualize on the map. Summary charts will update based on the displayed layers.", unsafe_allow_html= True)
    
    #display toggles to turn on data layers            
    for section, slider_key, items in layer_config:
        with st.expander(section):
            # st.slider("transparency", 0.0, 1.0, 0.1 if slider_key != "calfire" else 0.15, key=slider_key)
            for item in items:
                if len(item) == 5:
                    _, label, toggle_key, default, citation = item
                    st.toggle(label, key=toggle_key, value=default, help = citation)
                else:
                    _, label, toggle_key, citation = item
                    st.toggle(label, key=toggle_key)
    st.divider() 
    #basemap choices
    b = st.selectbox("Basemap", basemaps,index= 40)
    m.add_basemap(b)
    st.divider()
    # adding github logo 
    st.markdown(f"<div class='spacer'>{github_html}</div>", unsafe_allow_html=True)
    st.markdown(":left_speech_bubble: [Get in touch or report an issue](https://github.com/boettiger-lab/CBN-taskforce/issues)")



column = select_column[color_choice]
colors = color_table(select_colors, color_choice, column)
main = st.container()
with main:
    map_col, stats_col = st.columns([3,2])


## parameters for mapping the data (if we didn't use llm)
if 'llm_output' not in locals():
    df_network, _, df_tab, df_bar_30x30 = get_summary_table(ca, column, select_colors, color_choice, filter_cols, filter_vals,colorby_vals)
    style = get_pmtiles_style(style_options[color_choice], alpha, filter_cols, filter_vals)
    bounds = [-124.42174575, 32.53428607, -114.13077782, 42.00950367]
else:
    style = get_pmtiles_style_llm(style_options[color_choice], ids)
    df_network, _ = get_summary_table_sql(ca, column, colors, ids)

## mapping data 
legend, position, bg_color, fontsize = get_legend(style_options, color_choice, df_network, column)
# m.add_legend(legend_dict = legend, position = position, bg_color = bg_color, fontsize = fontsize)
m.add_legend(legend_dict = legend, position = position)

m.add_pmtiles(ca_pmtiles, style=style, name="CA", tooltip=False, zoom_to_layer=True)

if 'bounds' in locals(): 
    m.zoom_to_bounds(bounds)

# check if any layer toggle is active
any_chart_toggled = any(
    st.session_state.get(toggle_key, False)
    for _, _, items in layer_config
    for _, _, toggle_key, *_ in items
)

# check if using stacked bar chart 
show_stacked = (column not in ["status", "gap_code"]) and ('df_bar_30x30' in locals())

if 'llm_output' in locals():
    show_chatbot_chart = llm_output.columns.any() in keys
else:
    show_chatbot_chart = False
# main display 
with main:
    map_col, stats_col = st.columns([3,2])

    with map_col:
        m.to_streamlit(height=650) # adding map
        with st.expander("üîç View/download data"): # adding data table  
            if 'llm_output' not in locals():
                st.dataframe(df_tab, use_container_width = True)  
            else:
                if 'geom' in llm_output.columns:
                    llm_output = llm_output.drop('geom',axis = 1)
                st.dataframe(llm_output, use_container_width = True)

    with stats_col:
        with st.container():
            st.markdown('')
            st.altair_chart(area_chart(df_network, column, color_choice), use_container_width=True)
            st.markdown('<p class="caption-shift-up">*Chart updates based on filters.</p>', unsafe_allow_html=True)

            # display the pill selection if we will use any barcharts
            if any_chart_toggled or show_stacked or show_chatbot_chart:
                option_map = {
                    'percent': "%",
                    'acres': "Acres",
                }
                chart_choice = st.pills(
                    label="Bar chart metrics",
                    options=option_map.keys(),
                    format_func=lambda option: option_map[option],
                    selection_mode="single",
                    label_visibility="collapsed",
                    default="percent",
                )
            if chart_choice:    
                if show_stacked:
                    y = 'percent_group' if chart_choice == 'percent' else 'acres'
                    if color_choice == 'Resilient & Connected Network': # line break, this title is long 
                         color_choice = 'Resilient &\n Connected Network'
                    chart = stacked_bar(df = df_bar_30x30, x = column, y = y, metric = chart_choice, title = color_choice + '\n by 30x30 Status', colors = colors)
                    st.altair_chart(chart, use_container_width=True) 
                    # st.markdown('')
                    if chart_choice == 'percent':
                        st.markdown(f'<p class="caption">*Percent of {color_choice} within each 30x30 conservation status.</p>', unsafe_allow_html=True)
                    else:
                        st.markdown(f'<p class="caption">*Acres of {color_choice} within each 30x30 conservation status.</p>', unsafe_allow_html=True)

                # data layer summary charts   
                for _, _, items in layer_config:
                    for suffix, label, toggle_key, *_ in items:
                        if st.session_state.get(toggle_key, False):
                            suffix = suffix.replace("pct_", "").replace("-", "_")
                            if ('Richness' in label) & ('Endemic' not in label) & ('Rare' not in label): 
                                label = f"Top {label}"
                            if ("Richness" in label) | ("Land" in label) | ("Communities" in label):
                                label = f"{label}\n"
                            if chart_choice == 'percent':
                                # % of NETWORK
                                feature_col = f"pct_network_{suffix}"
                                st.altair_chart(bar_chart(df_network, column, feature_col, label, metric=chart_choice, percent_type = "Network"), use_container_width=True)
    
                                # % of FEATURE
                                feature_col = f"pct_feature_{suffix}"
                                _, df_feature,_,_ = get_summary_table(ca, column, select_colors, color_choice, filter_cols, filter_vals,colorby_vals, feature_col)
                                st.altair_chart(bar_chart(df_feature, column, feature_col, label, metric=chart_choice,percent_type = "Feature"), use_container_width=True)

                            else: # acres chart 
                                feature_col = f"acres_{suffix}"
                                st.altair_chart(bar_chart(df_network, column, feature_col, label, metric=chart_choice), use_container_width=True)


            else:
                st.warning("Please select a metric to display bar chart.")
with main:
    with map_col:
        st.caption("***The label 'established' is inferred from the California Protected Areas Database, which may introduce artifacts. For details on our methodology, please refer to our <a href='https://github.com/boettiger-lab/CBN-taskforce' target='_blank'>our source code</a>.", unsafe_allow_html=True)
        
        st.caption("***Under California‚Äôs 30x30 framework, only GAP codes 1 and 2 are counted toward the conservation goal.") 

st.divider()

with open('app/footer.md', 'r') as file:
    footer = file.read()
st.markdown(footer)


